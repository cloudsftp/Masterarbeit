from pathlib import Path
from textwrap import dedent
from typing import List, Dict

from util.exceptions import CustomException

from execution.frame import Frame
from configuration.diagrams import Diagram


# Symbolic Sequences

SYMBOLS = ["A", "B", "C", "D"]


class Cycle:
    revolutions: List[Dict[str, int]]

    def __init__(self):
        self.revolutions = list()

    def add(self, symbol: str):
        if symbol not in SYMBOLS:
            return

        # first symbol in cycle
        if len(self.revolutions) == 0:
            first_rev = Cycle.new_rev()
            first_rev[symbol] += 1
            self.revolutions.append(first_rev)

            return

        need_new_rev = False

        symbol_num = SYMBOLS.index(symbol)
        current_rev = self.revolutions[-1]

        for i, s in enumerate(SYMBOLS):
            if current_rev[s] > 0 and SYMBOLS.index(s) > symbol_num:
                need_new_rev = True

        # new revolution needed
        if need_new_rev:
            new_rev = Cycle.new_rev()
            new_rev[symbol] += 1
            self.revolutions.append(new_rev)

            return

        current_rev[symbol] += 1

    def new_rev() -> Dict[str, int]:
        return {symbol: 0 for symbol in SYMBOLS}

    def normalize(self):
        if len(self.revolutions) < 2:
            # only run if there are at least 2 revolutions
            return

        last_pos = 0  # must be positive at least
        for i, s in enumerate(SYMBOLS):
            if self.revolutions[-1][s] > 0:
                last_pos = i

        first_pos = len(SYMBOLS) - 1  # must be positive at least
        for i, s in enumerate(SYMBOLS):
            if self.revolutions[0][s] > 0:
                first_pos = i
                break

        if first_pos < last_pos:
            # if the last positive symbol of the last revolution
            # is later than the first symbol of the first revolution
            # nothing has to be done
            return

        last_rev = self.revolutions.pop(-1)
        first_rev = self.revolutions[0]
        for s in SYMBOLS:
            first_rev[s] += last_rev[s]

    def period(self) -> int:
        res = 0

        for rev in self.revolutions:
            for s in SYMBOLS:
                res += rev[s]

        return res

    def __eq__(self, o) -> bool:
        return hash(self) == hash(o)

    def __hash__(self) -> int:
        res = 0

        for rev in self.revolutions:
            # just adding up a hash function for all revolutions
            # is rotation invariant
            for s in SYMBOLS:
                res += hash(s) * rev[s]

        return res

    def __str__(self) -> str:
        res = ""

        for rev in self.revolutions:
            for s in SYMBOLS:
                if rev[s] > 0:
                    res += f"{s} {rev[s]}  "

            res += "  "

        res += f"({self.period()})"

        return res


def process_simple_symbolic(frame: Frame):
    if frame.diagram.animation != None:
        print("Symbolic Sequence not yet supported for animation")
        return

    cycles = set()

    with open(get_symbolic_raw_file(frame)) as raw_file:
        for line in raw_file:
            if line == "\n" or line[0] == "#":
                continue

            cycle = Cycle()

            for char in line:
                cycle.add(char)

            cycle.normalize()
            cycles.add(cycle)

    with open(get_symbolic_target_file(frame), "w") as target_file:
        target_file.write(
            dedent(
                f"""Coexisting cycles: {len(cycles)}
                
                """
            )
        )

        for n, cycle in enumerate(cycles):
            target_file.write(f"{n:2d}: {cycle}\n")

        target_file.write(
            dedent(
                f"""

                # This file is automatically generated
                """
            )
        )


# Paths


def get_symbolic_raw_file(frame: Frame) -> Path:
    return frame.path / "periodic_symbolic_sequence.tna"


def get_symbolic_target_file(frame: Frame) -> Path:
    return frame.diagram.path / "symbolic.txt"
